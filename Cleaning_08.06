## falsche steplength bisher!!!
## nachher die erste beobachtung für jeden ID_burst löschen, code dafür steht ganz unten!

setwd("C:/Users/Admin/Documents/Robben")
data <- read.delim("~/Robben/seal_data_20170420.txt")

#remove unneeded columns
data <- data[,c(1,2,4:18)]

### datacleaning
#first column
data[,1] <- gsub("S01","12",data[,1])
data[,1] <- gsub("S02","13",data[,1])
data[,1] <- gsub("S03","14",data[,1])
data[,1] <- gsub("S04","15",data[,1])
data[,1] <- gsub("S05","16",data[,1])
data[,1] <- gsub("S06","17",data[,1])
data[,1] <- gsub("S07","18",data[,1])
data[,1] <- gsub("S08","19",data[,1])
data[,1] <- gsub("S09","20",data[,1])
data[,1] <- gsub("S10","21",data[,1])
data[,1] <- gsub("G", "",data[,1])   #remove "G"s
data[,1] <- gsub("01","1", data[,1]) #remove unnecessary "0"s
data[,1] <- gsub("02","2", data[,1])
data[,1] <- gsub("03","3", data[,1])
data[,1] <- gsub("04","4", data[,1])
data[,1] <- gsub("05","5", data[,1])
data[,1] <- gsub("06","6", data[,1])
data[,1] <- gsub("07","7", data[,1])
data[,1] <- gsub("08","8", data[,1])
data[,1] <- gsub("09","9", data[,1])
data[,1] <- as.factor(data[,1])
#Seal 1 to 11 are the grey seals

#sex column
data[,11] <- gsub("Male","0",data[,11])
data[,11] <- gsub("Female","1",data[,11])
data[,11] <- as.integer(data[,11])
#male = 0

#steplen function (in km)
earth.dist <- function (long1, lat1, long2, lat2)
{
        rad <- pi/180
        a1 <- lat1 * rad
        a2 <- long1 * rad
        b1 <- lat2 * rad
        b2 <- long2 * rad
        dlon <- b2 - a2
        dlat <- b1 - a1
        a <- (sin(dlat/2))^2 + cos(a1) * cos(b1) * (sin(dlon/2))^2
        c <- 2 * atan2(sqrt(a), sqrt(1 - a))
        R <- 6378.145
        d <- R * c
        return(d)
}
steplen <-earth.dist(long1=data[,4],lat1=data[,5],long2=data[,6],lat2=data[,7])
steplen <- steplen *1000 # convert to meters
data$steplen <- steplen
colnames(data)[colnames(data) == "V16"] <- "steplen"

#calculate % of bathymetry
dive_dep2 <- data$max.dep/data$bathymetry
dive_dep2[dive_dep2>=1.0] <- 0.999999 #to prevent values > 1
data$dive_dep <- dive_dep2

#dive id
levels(data$ID_burst)<-c(1:1020) 
#this may lead to problems when analyzing them by species
#in that case, just rerun the code above for the Harbour Seals dataset

data <- data[,c(1:2,4:13,15:17)]

grey_end <- match(unique(data$ID), data$ID)[12]
data <- data[1:(grey_end-1),]

#subsample

colnames(data$start.lon) <- "x" #some renaming could be moved to data cleaning
colnames(data$start.lat) <- "y"


subsam <- 20 #subsample size
numvar <- ncol(data) #number of variables that will be included in the data set produced

#turning angle function (from Roland)

turnAngle <- function(x,y,z){
        v <- c(y[1]-x[1],y[2]-x[2])
        w <- c(z[1]-y[1],z[2]-y[2])
        angle <- atan2(w[2],w[1])-atan2(v[2],v[1])
        if (angle <= -pi) angle <- angle + 2*pi
        if (angle > pi) angle <- angle -2*pi
        return(angle)
}



#function that has one ID_burst as input and handles the calculations for it

handleburst <- function(oneburstdata,subsam){
        numleftover <- nrow(oneburstdata) %% subsam
        leftover <- oneburstdata[(nrow(oneburstdata)-numleftover+1):nrow(oneburstdata),]
        eaten <- oneburstdata[1:(nrow(oneburstdata)-numleftover),]
        nss <- nrow(eaten)/subsam
        out <- matrix(rep(NA,(nss+1)*numvar), nrow = nss+1, ncol = numvar) #adjust according to no of variables (possible max is ncol(eaten))
        for (i in 1:nss){
                out[i,1] <-mean(eaten$dive_dep[((i-1)*subsam+1):(i*subsam)])
                out[i,2] <-mean(eaten$dive.dur[((i-1)*subsam+1):(i*subsam)])
                out[i,3] <-mean(eaten$surf.dur[((i-1)*subsam+1):(i*subsam)])
        }
        
        out[i+1,1] <- mean(leftover$dive_dep)
        out[i+1,2] <- mean(leftover$dive.dur)
        out[i+1,3] <- mean(leftover$surf.dur)
        
        eatenss <- eaten[seq(1,nrow(eaten),by=subsam),]
        steps <- turns <- rep(NA,nss)
        for (k in 2:(nss-1)){
                x<-c(eatenss$x[k-1],eatenss$y[k-1])
                y<-c(eatenss$x[k],eatenss$y[k])
                z<-c(eatenss$x[k+1],eatenss$y[k+1])
                if (!is.na(x[1]) & !is.na(y[1]) & !is.na(z[1])) turns[k]<-turnAngle(x,y,z)
                steps[k]<-sqrt(sum((z-y)^2))
        }  
        
        out[1:nrow(eatenss),4] <- turns
        out[1:nrow(eatenss),5] <- steps
        
        return(out)
}

split2list <- split(data[1:100000,], f = data[1:100000,3]) #split ID_bursts into a list of matricies
subsamplelist <- lapply(split2list, function(x) handleburst(x,subsam)) #apply function to each ID_burst

subsample <- do.call(rbind,subsamplelist) #reunite into final dataset


write.csv(subsample, file = "subsample_20.csv")


#get rid of wrong angles
ID_burst_vector <- match(unique(data$ID_burst), data$ID_burst)
data <- data[-ID_burst_vector,]
